---
title: "[CTF] 드림핵 CSRF-1"
date: 2025-09-18 18:20:00 +0900
categories: [CTF, Web]
tags: [CTF, CSRF]
description: "드림핵 CSRF-1"
author: "송지민"
toc: true
---

## 문제 개요
이번 문제는 `/vuln`, `/flag`, `/memo`, `/admin/notice_flag` 경로가 있는 플라스크 앱이었다. 이전 문제들과 비슷한 구조지만 필터링과 로컬 판정 로직에 차이가 있어 우회 방법을 찾아야 했다.

- `/vuln?param=...` : param 값을 출력하되 XSS 필터가 적용되어 `["frame","script","on"]` 단어는 `"*"`로 치환된다.
- `/flag` : POST로 param을 받아 내부에서 `check_csrf(param)` 을 호출해 `/vuln?param=...` 를 로컬 브라우저(셀레니움)로 열게 함.
- `/memo?memo=...` : 전달된 memo 값을 누적해 저장
- `/admin/notice_flag` : 로컬에서만 접근 가능하며 `userid=admin`이면 FLAG를 memo에 기록

아래는 문제에서 제공된 **원본 소스코드 전체**다.

```python
#!/usr/bin/python3
from flask import Flask, request, render_template
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
import urllib
import os

app = Flask(__name__)
app.secret_key = os.urandom(32)

try:
    FLAG = open("./flag.txt", "r").read()
except:
    FLAG = "[**FLAG**]"


def read_url(url, cookie={"name": "name", "value": "value"}):
    cookie.update({"domain": "127.0.0.1"})
    try:
        service = Service(executable_path="/chromedriver")
        options = webdriver.ChromeOptions()
        for _ in [
            "headless",
            "window-size=1920x1080",
            "disable-gpu",
            "no-sandbox",
            "disable-dev-shm-usage",
        ]:
            options.add_argument(_)
        driver = webdriver.Chrome(service=service, options=options)
        driver.implicitly_wait(3)
        driver.set_page_load_timeout(3)
        driver.get("http://127.0.0.1:8000/")
        driver.add_cookie(cookie)
        driver.get(url)
    except Exception as e:
        driver.quit()
        print(str(e))
        # return str(e)
        return False
    driver.quit()
    return True


def check_csrf(param, cookie={"name": "name", "value": "value"}):
    url = f"http://127.0.0.1:8000/vuln?param={urllib.parse.quote(param)}"
    return read_url(url, cookie)


@app.route("/")
def index():
    return render_template("index.html")


@app.route("/vuln")
def vuln():
    param = request.args.get("param", "").lower()
    xss_filter = ["frame", "script", "on"]
    for _ in xss_filter:
        param = param.replace(_, "*")
    return param


@app.route("/flag", methods=["GET", "POST"])
def flag():
    if request.method == "GET":
        return render_template("flag.html")
    elif request.method == "POST":
        param = request.form.get("param", "")
        if not check_csrf(param):
            return '<script>alert("wrong??");history.go(-1);</script>'

        return '<script>alert("good");history.go(-1);</script>'


memo_text = ""


@app.route("/memo")
def memo():
    global memo_text
    text = request.args.get("memo", None)
    if text:
        memo_text += text
    return render_template("memo.html", memo=memo_text)


@app.route("/admin/notice_flag")
def admin_notice_flag():
    global memo_text
    if request.remote_addr != "127.0.0.1":
        return "Access Denied"
    if request.args.get("userid", "") != "admin":
        return "Access Denied 2"
    memo_text += f"[Notice] flag is {FLAG}\n"
    return "Ok"


app.run(host="0.0.0.0", port=8000)
```

---

## 내가 실제로 푼 방법
코드를 확인하면서 취약점을 두 가지로 정리했다.

1. `/vuln`은 `["frame","script","on"]` 만 필터링하지만, 필터는 단어 치환 방식(`replace`)이라 태그의 꺽쇠(`<` `>`)는 그대로 남아 있고 다른 태그를 사용할 수 있다.
2. `check_csrf`는 내부에서 받은 `param`을 그대로 `read_url`에 넣어 로컬에서 실행하도록 만든다. 즉, `read_url`이 로컬(셀레니움)에서 해당 URL을 열게 되어 내부 접근이 가능하다는 판정을 얻게 된다.

따라서 아이디어는 간단했다. `/admin/notice_flag`는 로컬 요청에 대해 `userid=admin`이면 FLAG를 memo에 기록하므로, `/flag`에 param으로 admin 경로 호출을 보내게 만들면 된다.

### 내가 사용한 페이로드
```html
<img src="/admin/notice_flag?userid=admin">
```

### PoC 요청
```bash
curl -X POST -F 'param=<img src="/admin/notice_flag?userid=admin">' http://TARGET:8000/flag
```

설명:
- `/flag`에 POST하면 `check_csrf(param)`이 `http://127.0.0.1:8000/vuln?param=<quote(param)>` 를 내부 셀레니움으로 연다.
- `/vuln`은 필터로 `frame`, `script`, `on` 단어를 `"*"`로 치환하지만 `<img src="/admin/notice_flag?userid=admin">` 에는 해당 단어들이 없어 그대로 출력된다.
- 셀레니움 봇이 `/vuln?param=<img ...>` 를 열고 페이지에서 이미지 태그를 평가하면서 `/admin/notice_flag?userid=admin` 로 요청을 보낸다.
- `/admin/notice_flag`는 로컬 요청이고 `userid=admin`이므로 memo에 FLAG가 저장된다.
- 최종적으로 `/memo`에서 FLAG를 확인했다.

---

## 재현 흐름
1. 공격자: `POST /flag` with `param=<img src="/admin/notice_flag?userid=admin">`  
2. 서버: `check_csrf` → `read_url` → 셀레니움 실행 → `driver.get("/vuln?param=<payload>")`  
3. 봇: `/vuln` 렌더링 후 이미지 요청으로 `/admin/notice_flag?userid=admin` 호출  
4. `/admin/notice_flag`는 로컬 + admin 조건 만족 → memo에 FLAG 저장  
5. 공격자: `/memo`에서 FLAG 확인

---

## 왜 이게 가능했나
`/vuln`의 필터가 제한적이고 `check_csrf`가 내부에서 받은 URL을 로컬에서 그대로 실행하게 만들어, 로컬 전용 관리자 경로에 이미지 요청을 트리거할 수 있었기 때문이다.

---

## 마무리
CSRF-1은 필터 우회 + 로컬 실행 판정 조합으로 내부 관리자 경로를 타격한 문제였다. 간단하게 파고 들어서 바로 해결한 유형이라 블로그 기록용으로 남겼다.
