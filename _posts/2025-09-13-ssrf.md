---
title: "[Infosec] Server-Side Request Forgery (SSRF) 완전 정리"
date: 2025-09-13 23:00:00 +0900
categories: [보안, Web]
tags: [웹해킹, ssrf, injection, security, web]
description: "서버를 이용하여 요청을 위조하라"
author: "송지민"
toc: true
---

# 서버를 시켜 내부망을 털게 만드는 은밀한 공격

**Server-Side Request Forgery (SSRF)** 는 웹 서비스의 요청을 변조하여, **서버가 대신 공격자가 원하는 곳으로 요청을 보내도록 만드는 취약점**입니다.  
브라우저가 요청을 보내는 **CSRF**와 달리, **SSRF는 웹 서비스 자체의 권한으로 요청**을 보낼 수 있다는 점이 큰 차이입니다.

즉, 공격자는 서버를 **프록시**처럼 악용하여 내부망이나 외부 리소스를 공격할 수 있습니다.

---

## ✨ 왜 위험한가?
- 서버는 **내부망에 접근할 수 있는 권한**을 가지고 있음  
- 백오피스, 내부 API, DB 관리 페이지 등은 외부에서 직접 접근 불가 → SSRF로 우회 가능  
- 최근 **마이크로서비스 아키텍처**가 늘어나면서, SSRF의 파급력이 더욱 커짐  

---

## SSRF 발생 유형

### 1. 이용자가 입력한 URL에 요청을 보내는 경우

```python
from flask import Flask, request
import requests

app = Flask(__name__)

@app.route("/image_downloader")
def image_downloader():
    image_url = request.args.get("image_url", "")
    response = requests.get(image_url)
    return (
        response.content,
        200,
        {"Content-Type": response.headers.get("Content-Type", "")},
    )
```

#### 문제점
```bash
http://127.0.0.1:8000/image_downloader?image_url=http://127.0.0.1:8000/request_info
```
→ 브라우저 정보가 아닌 **python-requests**가 출력됨.  
→ 즉, 사용자가 아니라 **서버가 요청을 보낸 것**임.

---

### 2. 웹 서비스 요청 URL에 입력값이 포함되는 경우

```python
INTERNAL_API = "http://api.internal/"

@app.route("/v1/api/user/information")
def user_info():
    user_idx = request.args.get("user_idx", "")
    response = requests.get(f"{INTERNAL_API}/user/{user_idx}")
```

#### 문제점
```bash
http://api.internal/search?user_name=secret&user_type=private#&user_type=public
```
- `#` 이후 문자열은 무시되므로, 공격자가 의도한 **private** 쿼리 실행 가능

---

### 3. 요청 Body에 입력값이 포함되는 경우

```python
@app.route("/v1/api/board/write", methods=["POST"])
def board_write():
    title = request.form.get("title", "")
    body = request.form.get("body", "")
    data = f"title={title}&body={body}&user=guest"
    response = requests.post("http://127.0.0.1:8000/board/write", data=data)
    return response.content
```

#### 문제점
```bash
title=title&user=admin&body=body&user=guest
```
- 파라미터 덮어쓰기 → **user=admin**으로 인식

---

## 🛠 공격 활용 예시

1. **내부망 스캔**
   ```bash
   /fetch?url=http://127.0.0.1:8080/admin
   ```

2. **클라우드 메타데이터 탈취**
   ```bash
   /fetch?url=http://169.254.169.254/latest/meta-data/
   ```

3. **Redis, Memcached 등 비인가 접근**
   ```bash
   /fetch?url=gopher://127.0.0.1:6379/_FLUSHALL
   ```

---

## ✅ 방어 방법
- 화이트리스트 기반으로 허용된 도메인만 요청  
- 내부망 주소 (`127.0.0.1`, `169.254.*`, `::1`, `10.*`, `192.168.*`) 차단  
- 프로토콜 제한 (`http/https`만 허용, `file://`, `gopher://` 차단)  
- 요청 시간 제한 / 응답 크기 제한  
- Proxy 레이어 도입하여 필터링  

