---
title: "[Infosec] Content Security Policy (CSP)"
date: 2025-09-18 16:00:00 +0900
categories: [보안, Web]
tags: [웹해킹, CSP, XSS, Policy]
description: "XSS 피해를 줄이고 위협을 감지하기 위한 CSP의 개념, 실전 적용 예시, 배포 전략과 주의사항."
author: "송지민"
toc: true
---

> **요약**  
> Content-Security-Policy(CSP)는 브라우저 단에서 페이지가 로드·실행할 수 있는 자원과 행위를 제한하여 XSS, 데이터 인젝션 공격의 피해를 줄이고, 위반을 감지(리포트)하도록 돕는 보안 계층입니다. CSP는 방어의 한 구성요소이며, 입력 검증·출력 이스케이프 등 다른 보안 대책과 함께 사용해야 효과적입니다.

---

## 1. CSP란 무엇인가 (개념)
CSP는 서버가 브라우저에 전송하는 HTTP 헤더(또는 HTML `<meta>` 태그)를 통해 **어떤 리소스(스크립트/스타일/이미지 등)를 어디서 로드할 수 있는지**, 어떤 행위를 허용하는지를 선언하는 정책입니다. 브라우저는 이 정책을 기준으로 리소스 로드를 차단하거나 보고(report)합니다.

주요 목적
- 외부/인라인 스크립트 실행을 제한해 XSS 피해를 줄임
- 악성 리소스 로드(예: 외부 스크립트 포함)를 차단
- 정책 위반을 보고하여 이상 징후를 모니터링

> **중요**: CSP는 "완전한 XSS 방지책"이 아닙니다. 잘못 구성되거나 허용 범위가 넓으면 우회될 수 있습니다.

---

## 2. CSP 문법과 기본 개념
CSP는 여러 `directive`(지시문)를 세미콜론(;)으로 구분해 나열합니다. 각 지시문은 리소스 타입(스크립트, 이미지 등)과 허용되는 출처 목록을 명시합니다.

형식 예:
```
Content-Security-Policy: <directive> <source-list>; <directive> <source-list>; ...
```

### 자주 쓰이는 지시문(요약)
- `default-src` — 명시하지 않은 지시문의 기본값
- `script-src` — 스크립트(및 `inline` 실행) 관련 출처와 예외
- `style-src` — 스타일시트 관련 출처와 예외
- `img-src` — 이미지 출처
- `connect-src` — XHR, fetch, WebSocket 등 네트워크 연결 출처
- `frame-src` / `child-src` — iframe 등 프레임 소스
- `base-uri` — `<base>` 요소의 허용 출처 (클릭재작성 방지)
- `object-src` — 플러그인(object/embed) 소스 (권장: 'none')
- `report-uri` / `report-to` — 위반 리포트를 받을 엔드포인트

### 소스 표현
- `'self'` — 현재 오리진
- `'none'` — 허용 없음
- `https://cdn.example.com` — 특정 출처
- `https://*.example.com` — 와일드카드(서브도메인)
- `data:` / `blob:` / `filesystem:` — 특정 스킴 허용(주의)
- `'unsafe-inline'` / `'unsafe-eval'` — 위험한 예외(권장 금지)
- `nonce-<base64>` — 요청별 난수(비권장: 재사용 금지)
- `<alg>-<base64>` (`'sha256-...'`) — 인라인 코드 해시 허용

---

## 3. 인라인 코드·Eval 관련 기본 정책
- CSP는 기본적으로 **인라인 스크립트와 `eval`류(문자열 → 코드 실행)** 를 차단합니다.
- 예시로 `<script>alert(1)</script>`와 `javascript:` URL, `on*` 이벤트 속성, `eval("...")` 등은 기본적으로 차단됩니다.
- 안전하게 인라인을 허용하려면 **nonce**(요청마다 다른 값) 또는 **해시(hash)** 방식을 사용하세요. 절대 `'unsafe-inline'`을 전역 허용하지 마십시오.

---

## 4. 실전 예시 헤더 (복사해서 사용 가능)

### 4.1 엄격(권장) — 내부 리소스만 허용
```
Content-Security-Policy: default-src 'none'; base-uri 'self'; script-src 'self' 'sha256-<HASH1>'; style-src 'self' 'sha256-<HASH2>'; img-src 'self' data:; connect-src 'self'; object-src 'none'; frame-ancestors 'none'; report-to csp-endpoint;
```

### 4.2 실용형(서드파티 일부 허용)
```
Content-Security-Policy: default-src 'none'; script-src 'self' https://cdn.example.com; style-src 'self' https://fonts.googleapis.com; img-src 'self' data: https://images.example.com; connect-src 'self' https://api.example.com; object-src 'none'; report-uri /csp-report;
```

### 4.3 모니터링용(점진 도입)
```
Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-report;
```
- `Report-Only`는 차단하지 않고 위반 사례를 수집하는 데 사용됩니다. 배포 전 필수 단계로 권장합니다.

---

## 5. nonce와 해시 (nonce vs hash)
- **nonce-<value>**: 서버가 각 응답에 랜덤(충분히 긴 base64) nonce를 삽입하고, 해당 nonce를 스크립트 태그의 `nonce` 속성에도 붙입니다. 브라우저는 그 nonce가 일치할 때만 인라인 스크립트를 허용합니다.  
  - 장점: 런타임에서 동적 스크립트를 허용 가능.
  - 주의: nonce는 **절대 재사용 금지**(각 요청마다 새로 생성).
- **'sha256-<value>'**: 빌드 시 스크립트 내용의 해시를 계산해 CSP에 넣으면 해당 정확한 내용만 허용됩니다.  
  - 장점: 빌드 파이프라인에서 고정된 스크립트를 엄격히 허용.
  - 단점: 동적 스크립트에 적용 어렵다.

---

## 6. 배포 전략 (권장 절차)
1. **report-only 모드로 시작** — 위반 로그 수집  
2. 로그를 분석해 허용된 서드파티/내부 스크립트 목록 생성  
3. 정책을 점진적으로 강화(unsafe-inline/unsafe-eval 제거, 해시/nonce 도입)  
4. 정책을 강제 적용(CSP 헤더)하고 모니터링 지속  
5. CI/CD에 CSP 검증(빌드 시 스크립트 해시 검증, nonce 자동화) 포함

---

## 7. 흔한 실수·주의사항
- **'unsafe-inline'을 허용**하면 CSP 효과 대부분이 사라짐. 가능한 제거하라.  
- **고정된 nonce**를 사용하면 공격자가 재사용 가능한 값을 이용해 인라인 코드를 실행할 수 있다. **매 요청마다 새 nonce를 발급**해야 함.  
- `report-uri`/`report-to`를 통해 수집되는 리포트에는 민감 정보가 포함될 수 있으므로 접근 제어 필요.  
- `data:` / `blob:` 허용은 XSS 벡터를 확장시킬 수 있으니 최소화.  
- CSP는 브라우저 구현에 따라 동작 차이가 있을 수 있음(특히 구형 브라우저).

---

## 8. 우회(테스터 용 간단 정리) — 핵심 포인트
> 운영자용 문서와 분리된 별도 우회 가이드가 필요합니다. 여기선 핵심적인 우회 벡터만 간단히 요약합니다.

- **허용된 도메인(whitelist) 악용**: 허용된 CDN이나 저장소에 악성 스크립트를 업로드하면 실행됨.  
- **Report-Only 모드 오해**: `Report-Only`는 차단하지 않으니 위험을 방치하지 말 것.  
- **nonce/sha 취약점**: nonce가 고정되거나 해시가 일치할 수 있는 스크립트가 동적으로 생성되면 우회 위험.  
- **상호 컨텍스트 우회**: `script-src`가 엄격하더라도 `img-src`/`style-src`/`frame-src`를 이용해 간접 실행(예: `iframe srcdoc`) 가능.  
- **브라우저 차이/정규화**: 일부 브라우저의 URL·문자열 정규화 차이를 이용해 `javascript:` 스킴·인라인 실행 우회 가능.

---

## 9. 테스트·모니터링 팁
- **리포트 분석**: 위반 리포트의 `blocked-uri`, `violated-directive`, `source-file` 필드를 우선 분석.  
- **Burp/브라우저 테스트**: 헤더를 제거하거나 `Report-Only`로 바꿔 실험해보자.  
- **브라우저 호환성**: Chrome/Firefox/Safari/Edge(모바일 포함)에서 정책 동작 검증.  
- **자동화**: CI에서 스크립트 해시 체크, nonce 자동화 테스트 추가.

---

## 10. 예시: 서버 측 nonce 생성 (Node.js/Express)
```js
// express middleware example (very simple illustration)
const crypto = require('crypto');

app.use((req,res,next) => {
  const nonce = crypto.randomBytes(16).toString('base64'); // request-unique
  res.locals.cspNonce = nonce;
  res.setHeader('Content-Security-Policy', `script-src 'self' 'nonce-${nonce}'; object-src 'none';`);
  next();
});
```
템플릿에서:
```html
<script nonce="{{cspNonce}}">
  // 안전하게 허용되는 인라인 코드
</script>
```

---

## 11. 결론
CSP는 XSS 피해를 줄이는 강력한 보호막이지만 **정확한 설계·배포·검증**이 필수입니다. `report-only`로 모니터링하고 점진적으로 정책을 엄격하게 조정하세요. CSP는 다른 보안 조치(입력 검증, 출력 이스케이프, CSP 외 보안 헤더)와 함께 운용해야 실효성을 가집니다.

---

## 부록: 빠른 예시(요약)
- Report-only 단계 예:
```
Content-Security-Policy-Report-Only: default-src 'self'; report-uri /csp-report;
```
- 최소 권한(권장) 예:
```
Content-Security-Policy: default-src 'none'; script-src 'self' 'sha256-...'; style-src 'self'; img-src 'self' data:; object-src 'none'; base-uri 'self'; frame-ancestors 'none';
```

---
