---
title: "[Infosec] Client‑Side Template Injection (CSTI) 정리"
date: 2025-09-24 12:00:00 +0900
categories: [보안, Web]
tags: [CSTI, Client-Side-Template-Injection, Vue, Angular, XSS, 방어]
description: "프레임워크를 이용한 취약점"
author: "송지민"
toc: true
---

# 개요
**Client‑Side Template Injection (CSTI)** 은 사용자가 입력한 값이 클라이언트 템플릿 엔진(예: Vue, Angular)의 **템플릿 구문**으로 해석되어 실행될 때 발생하는 취약점입니다. 보통 서버에서 HTML로 이스케이프(또는 인코딩)해서 출력해도, 그 출력물이 프레임워크의 템플릿 컨텍스트로 다시 파싱되면 임의 코드 실행(XSS)으로 연결될 수 있습니다.

이 글은 개념 → 취약성 탐지 방법 → 구체적 예제(Vue, Angular) → 방어책 순으로 정리합니다. 학습/방어 목적의 정리이며, 실제 서비스 테스트는 항상 허가된 환경에서만 진행하세요.

---

# 1. CSTI 핵심 포인트
- **문제 근원**: 서버에서 출력한 값(예: `&lt;`, `&gt;`로 이스케이프된 텍스트)이 클라이언트 프레임워크에 의해 템플릿으로 다시 해석되면 발생.
- **취약 영향**: 템플릿 표현식이 실행되어 단순 문자열 출력 이상의 작업(산술, 함수 호출, 전역 접근 등)이 일어남 → 결과적으로 XSS(스크립트 실행)로 이어질 수 있음.
- **발생 조건**:
  - 사용자 입력이 클라이언트 템플릿 컨텍스트(예: `{% raw %}{{ . . . }}{% endraw %}`)로 주입된다.
  - 템플릿 엔진이 런타임에 그 표현식을 평가(evaluate)할 수 있는 경우.
- **탐지 방법**: 템플릿식(예: `{% raw %}{{1+1}}{% endraw %}`)을 주입해서 산술 결과(2)가 출력되는지 확인. 출력된다면 CSTI 가능성 높음.

---

# 2. Vue (Vue 2 / Vue 3) 관련
## 2.1 동작 요약
- Vue 템플릿(`{% raw %}{{ }}{% endraw %}`)은 런타임에 내부 컨텍스트에서 표현식을 평가합니다.
- 보통 Vue는 바인딩한 데이터(`data`)를 안전하게 렌더하지만, 만약 **서버가 만든 문자열이 그대로 템플릿으로 파싱**되면 문제가 됩니다.

## 2.2 취약 상황 예시(문제 원인 요약)
- 서버에서 `htmlspecialchars()`로 `<`/`>`를 이스케이프해 출력하더라도, 그 텍스트 조각이 Vue 인스턴스의 템플릿으로 삽입되어 재해석될 수 있음.
- 예: 서버가 `{% raw %}{{1+1}}{% endraw %}`을 문자로 출력 → 클라이언트에서 Vue가 그 문자열을 템플릿으로 파싱 → `2` 출력.

## 2.3 탐지 예시
- URL에 `?msg={% raw %}{{1+1}}{% endraw %}` 같은 값을 넣어보고 페이지에서 `2`가 출력되는지 확인.
- 더 공격적(교육/CTF용) 탐지: `{% raw %}{{_Vue && _Vue.h && _Vue.h.constructor}}{% endraw %}` 같은 내부 객체 접근 시도를 통해 템플릿 내 접근 가능성을 확인할 수 있음(브라우저/버전마다 차이 있음).

## 2.4 알려진 익스플로잇 패턴 (개념 설명)
- Vue 내부 헬퍼나 렌더 함수의 `constructor`를 활용하면 `Function` 생성 → 동적 코드 실행 가능. 예: `{% raw %}{{_Vue.h.constructor("alert(1)")()}}{% endraw %}`
- **주의**: 위 표현식은 특정 Vue 구현/버전에서 동작 여부가 달라집니다. 목적은 “템플릿이 임의 표현식을 실행할 수 있다”는 점을 보여주는 예시입니다.

## 2.5 방어책 (Vue)
- **절대** 서버에서 사용자 입력을 “템플릿 원문”으로 주입하지 마세요. (예: 서버에서 생성한 HTML 조각을 `innerHTML`로 삽입한 뒤 Vue가 파싱하게 하는 행위 금지)
- 사용자 텍스트를 렌더할 때는 Vue의 안전한 바인딩 사용(`v-text` 또는 데이터 바인딩) — `v-html` 사용은 피함.
  - 안전: `<div v-text="userMsg"></div>`
  - 위험: `<div v-html="serverHtml"></div>` (특히 서버가 만든 문자열을 그대로 넣을 때)
- 입력 정화: 서버에서 HTML 엔티티로 이스케이프 해도 **클라이언트 템플릿 파서가 재해석**할 수 있으므로, 템플릿 컨텍스트에 넣을 필요가 있으면 **표현식을 전혀 포함하지 않는 문자열만 허용**하도록 검증.
- CSP 적용: `script-src 'self' 'nonce-...'` 처럼 강력한 CSP로 피해 규모를 줄임.
- 라이브러리: 신뢰할 수 있는 HTML 정화 라이브러리(예: DOMPurify)를 사용해 `v-html`에 넣을 콘텐츠를 정화.

---

# 3. AngularJS (1.x) 관련
> 주의: 본문에서 말하는 AngularJS는 구 버전(1.x)입니다. Angular(2+)는 런타임과 구조가 다릅니다.

## 3.1 동작 요약
- AngularJS도 템플릿(`{% raw %}{{ }}{% endraw %}`)을 런타임에 평가합니다. 표현식 내에서 일부 JS 표현식이 실행됩니다.
- AngularJS에는 자체적인 sanitizer가 있지만, 개발자가 의도적으로 `ng-bind-html` 등에 `sanitize`를 끄거나, 신뢰한 HTML을 바인딩하면 위험.

## 3.2 취약 탐지
- 서버에 `{% raw %}{{1+1}}{% endraw %}`을 포함시켜보고 결과가 계산되는지 확인.
- AngularJS에서는 `{% raw %}{{ constructor.constructor("alert(1)")() }}{% endraw %}` 같은 패턴으로 생성자 접근 가능 여부를 검사하는 사례가 알려져 있음(버전/설정 의존적).

## 3.3 방어책 (AngularJS)
- 사용자 입력을 템플릿으로 **직접** 주입하지 마세요.
- `ng-bind` / `{% raw %}{{ }}{% endraw %}` 을 사용해 일반 텍스트를 바인딩하되, `ng-bind-html`이나 `$sce.trustAsHtml` 같은 신뢰된 HTML 바인딩은 가능한 사용하지 마세요.
- AngularJS의 `$sanitize` 모듈을 활성화해 HTML을 정화하거나, 반드시 신뢰할 수 있는 콘텐츠만 허용.
- 가능하면 AngularJS 1.x는 더 이상 권장되지 않으므로 최신 프레임워크·라이브러리로 마이그레이션을 고려.

---

# 4. 탐지·테스트 체크리스트 (개발자/리뷰어용)
- 서버에서 출력되는 문자열이 클라이언트 템플릿 엔진에 의해 **다시 파싱되는 경로**가 있는지 점검.
- 템플릿 내에 사용자 입력을 넣는 모든 코드(`innerHTML`, `v-html`, `ng-bind-html`, 서버에서 생성된 템플릿 스니펫 등)를 목록화.
- `{% raw %}{{1+1}}{% endraw %}` 또는 짧은 템플릿 표현식을 주입해 결과(2)가 나오는지 테스트.
- 빌드/런타임에서 템플릿 함수 접근 여부(예: `constructor`)가 노출되는지 확인.
- CSP, sanitizer 적용 여부 및 `v-html`/`ng-bind-html` 사용 위치 파악.

---

# 5. 실무 권장 방어 요약
1. **템플릿 원문 주입 금지**: 서버에서 만든 문자열(템플릿 단위)을 클라이언트 템플릿 엔진에 넘겨 파싱하게 하지 마세요.  
2. **데이터 바인딩 사용**: 텍스트 렌더는 `v-text`/`ng-bind` 또는 일반 바인딩으로 처리하되, HTML 바인딩은 최소화.  
3. **정화·검증**: HTML 허용 시 DOMPurify, Angular `$sanitize` 등 검증된 툴로 정화.  
4. **콘텐츠 분리**: 업로드/외부 콘텐츠는 별도의 오리진에서 서비스하고, 그 오리진에 대해 스크립트 실행을 허용하지 마세요.  
5. **CSP 적용**: 인라인 스크립트 금지, nonce/hash 기반 정책 권장.  
6. **프레임워크 보안 가이드 준수**: Vue/Angular 공식 문서의 보안 섹션을 따르고, 오래된 라이브러리는 업그레이드.

---

# 6. 결론
Client‑Side Template Injection은 “서버에서 안전하게 이스케이프했다”는 착각에서 자주 발생합니다. 핵심은 **어디서 템플릿 파싱이 일어나는지(서버/클라이언트)** 와 **입력이 템플릿 문법으로 해석되는 경로를 제거**하는 것입니다. 템플릿 엔진의 동작 방식을 이해하고, 텍스트와 템플릿을 명확히 분리하는 설계가 가장 강력한 방어입니다.
